#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# 去重 DAPO / 数学类 VERL 格式 parquet 数据集
#
# 去重逻辑：
#   - 读取 parquet（train / test）
#   - 从 prompt 字段中抽取 question 文本（prompt[0]["content"]）
#   - 以 question 文本为 key 做去重
#   - 打印去重前后样本数
#   - 将去重后的数据保存到原目录下的新文件：
#       train_dedup.parquet / test_dedup.parquet
#
# 说明：
#   - 默认假设列结构为 VERL 格式：
#       data_source, prompt, ability, reward_model, extra_info
#   - prompt 是一个 list[{"role": "...", "content": "..."}]

import argparse
import os
from pathlib import Path
from typing import Any, Dict, List

import pandas as pd


def extract_question_from_prompt(prompt: Any) -> str:
    """
    从 VERL 格式的 prompt 字段中抽取 question 文本。

    prompt 一般形如：
        [
            {
                "role": "user",
                "content": "原始题目文本 ……"
            }
        ]
    """
    if isinstance(prompt, list) and len(prompt) > 0:
        first_turn = prompt[0]
        if isinstance(first_turn, dict):
            content = first_turn.get("content", "")
        else:
            content = str(first_turn)
    else:
        # 如果格式不符合预期，尽量转成字符串
        content = str(prompt)

    return content.strip()


def dedup_parquet(in_path: str, out_path: str, key_col_name: str = "question_key") -> None:
    """
    对单个 parquet 文件按题目文本去重，并写出新的 parquet。

    Args:
        in_path: 输入 parquet 路径
        out_path: 输出 parquet 路径
        key_col_name: 临时列名，用于存放 question 去重 key
    """
    in_path = os.path.expanduser(in_path)
    out_path = os.path.expanduser(out_path)

    if not os.path.exists(in_path):
        raise FileNotFoundError(f"Input parquet not found: {in_path}")

    print("\n" + "=" * 80)
    print(f"[INFO] Loading parquet: {in_path}")
    df = pd.read_parquet(in_path)
    n_before = len(df)
    print(f"[INFO] Loaded {n_before} rows")

    if "prompt" not in df.columns:
        raise KeyError(f"'prompt' column not found in parquet columns: {list(df.columns)}")

    # 从 prompt 中抽取 question 文本作为去重 key
    print("[INFO] Extracting question_key from 'prompt' column ...")
    df[key_col_name] = df["prompt"].apply(extract_question_from_prompt)

    # 查看一下重复情况
    dup_mask = df.duplicated(subset=[key_col_name], keep="first")
    n_dups = dup_mask.sum()
    print(f"[INFO] Found {n_dups} duplicated questions (based on question_key)")

    # 真正去重
    df_dedup = df.drop_duplicates(subset=[key_col_name], keep="first")
    n_after = len(df_dedup)

    # 去掉临时列
    df_dedup = df_dedup.drop(columns=[key_col_name])

    print("\n[RESULT]")
    print(f"  Before dedup: {n_before} rows")
    print(f"  After  dedup: {n_after} rows")
    print(f"  Removed     : {n_before - n_after} rows")

    # 保存到输出路径
    out_dir = os.path.dirname(out_path)
    if out_dir:
        os.makedirs(out_dir, exist_ok=True)

    print(f"\n[INFO] Saving deduplicated parquet to: {out_path}")
    df_dedup.to_parquet(out_path)
    print("[INFO] Done.")


def main():
    parser = argparse.ArgumentParser(description="Deduplicate VERL-style parquet by question text")

    parser.add_argument(
        "--train_parquet",
        type=str,
        default="/mnt/bn/protenix-3/xuyiran/yr/datasets/dapo17k/train.parquet",
        help="Path to train.parquet (VERL format) generated by previous script.",
    )
    parser.add_argument(
        "--test_parquet",
        type=str,
        default=None,
        help="Optional: Path to test.parquet for deduplication.",
    )
    parser.add_argument(
        "--suffix",
        type=str,
        default="_dedup",
        help="Suffix for output parquet files (default: _dedup). "
             "train.parquet -> train_dedup.parquet",
    )

    args = parser.parse_args()

    # 处理 train
    train_path = Path(os.path.expanduser(args.train_parquet))
    train_out = train_path.with_name(train_path.stem + args.suffix + train_path.suffix)
    dedup_parquet(str(train_path), str(train_out))

    # 可选：处理 test
    if args.test_parquet is not None:
        test_path = Path(os.path.expanduser(args.test_parquet))
        test_out = test_path.with_name(test_path.stem + args.suffix + test_path.suffix)
        dedup_parquet(str(test_path), str(test_out))


if __name__ == "__main__":
    main()
